# [How to Use K-Means Clustering for Image Segmentation using OpenCV in Python](https://www.thepythoncode.com/article/kmeans-for-image-segmentation-opencv-python)
To run this:
- `pip3 install -r requirements.txt`
- If you want to perform image segmentation on the image `image.jpg`:
    ```
    python kmeans_segmentation.py image.jpg
    ```
- For live camera, consider using `live_kmeans_segmentation.py`.
##
# [[] / []]()
Сегментация изображения — это процесс разделения изображения на несколько различных областей (или сегментов). Цель состоит в том, чтобы изменить представление изображения на более легкое и значимое изображение.

Это важный шаг в обработке изображений, так как реальные изображения не всегда содержат только один объект, который мы хотим классифицировать. Например, для самоуправляемых автомобилей изображение будет содержать дорогу, автомобили, пешеходов и т. Д. Таким образом, нам может потребоваться использовать сегментацию здесь для разделения объектов и анализа каждого объекта в отдельности (т. Е. Классификация изображений), чтобы проверить, что это такое.

СВЯЗАННЫЕ С: Как обнаружить человеческие лица в Python с помощью OpenCV.

В этом уроке мы увидим один метод сегментации изображений, который называется K-Means Clustering.

Кластеризация K-Средних — это неконтролируемый алгоритм машинного обучения, целью которого является разделение N наблюдений на кластеры K, в которых каждое наблюдение принадлежит кластеру с ближайшим средним значением. Кластер относится к набору точек данных, агрегированных вместе из-за определенного сходства. Для сегментации изображений кластеры здесь имеют разные цвета изображения.

Следующее видео должно познакомить вас с алгоритмом кластеризации K-Means:



Прежде чем погрузиться в код, нам нужно установить необходимые библиотеки:

pip3 install opencv-python numpy matplotlib
Давайте импортируем их:

import cv2
import numpy as np
import matplotlib.pyplot as plt
Я собираюсь использовать это изображение в демонстрационных целях. Не стесняйтесь использовать любые:

Изображение для сегментации в OpenCV Python

Загрузка изображения:

# read the image
image = cv2.imread("image.jpg")
Прежде чем мы что-либо сделаем, давайте преобразуем изображение в формат RGB:

# convert to RGB
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
Мы будем использовать функцию cv2.kmeans(), которая принимает 2D-массив в качестве входных данных, и поскольку наше исходное изображение является 3D (ширина, высота и глубина 3 значений RGB), нам нужно сгладить высоту и ширину в один вектор пикселей (значения 3 RGB):

# reshape the image to a 2D array of pixels and 3 color values (RGB)
pixel_values = image.reshape((-1, 3))
# convert to float
pixel_values = np.float32(pixel_values)
Попробуем распечатать форму результирующих значений пикселей:

print(pixel_values.shape)
Выпуск:

(2073600, 3)
Как и ожидалось, это результат сглаживания изображения с высоким разрешением (1920, 1050).

Если бы вы посмотрели видео, в котором объясняется алгоритм, вы бы увидели, что он говорит около 3-й минуты, что алгоритм останавливается, когда ни одно из назначений кластера не меняется. Ну, мы собираемся немного обмануть здесь, так как это большое количество точек данных, поэтому обработка займет много времени, мы собираемся остановиться либо при превышении некоторого количества итераций (скажем, 100), либо если кластеры перемещаются меньше, чем какое-то значение epsilon (давайте выберем 0,2 здесь), приведенный ниже код определяет критерии остановки в OpenCV:

# define stopping criteria
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
Если вы посмотрите на изображение, есть три основных цвета (зеленый для деревьев, синий для моря / озера и от белого до оранжевого для неба). В результате мы будем использовать три кластера для этого образа:

# number of clusters (K)
k = 3
_, labels, (centers) = cv2.kmeans(pixel_values, k, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
массив меток — это метка кластера для каждого пикселя, которая равна 0, 1 или 2 (так как k = 3), центры относятся к центральным точкам (значение каждого центроида).

cv2. KMEANS_RANDOM_CENTERS просто указывает OpenCV для случайного назначения значений кластеров изначально.

Если вы оглянетесь на код, мы не упомянули, что мы преобразовали сглаженные значения пикселей изображения в плавающие; мы сделали это, потому что cv2.kmeans() ожидает этого, давайте преобразуем их обратно в 8-битные значения пикселей:

# convert back to 8 bit values
centers = np.uint8(centers)

# flatten the labels array
labels = labels.flatten()
Теперь построим сегментированное изображение:

# convert all pixels to the color of the centroids
segmented_image = centers[labels.flatten()]
Преобразование обратно в исходную форму изображения и ее отображение:

# reshape back to the original image dimension
segmented_image = segmented_image.reshape(image.shape)
# show the image
plt.imshow(segmented_image)
plt.show()
Вот полученное изображение:

Результирующее сегментированное изображение с помощью OpenCV

Удивительно, мы также можем отключить некоторые кластеры в изображении. Например, давайте отключим кластер номер 2 и покажем исходное изображение:

# disable only the cluster number 2 (turn the pixel into black)
masked_image = np.copy(image)
# convert to the shape of a vector of pixel values
masked_image = masked_image.reshape((-1, 3))
# color (i.e cluster) to disable
cluster = 2
masked_image[labels == cluster] = [0, 0, 0]
# convert back to original shape
masked_image = masked_image.reshape(image.shape)
# show the image
plt.imshow(masked_image)
plt.show()
Вот полученное изображение:

Мачтовое изображение с помощью OpenCV

Вау, оказывается, что кластер 2 — это деревья. Не стесняйтесь:

Отключите другие кластеры и посмотрите, какие из них сегментированы точно.
Настройте параметры для получения лучших результатов (например, k).
Используйте другие изображения, которые четко содержат разные объекты с разными цветами.
Обратите внимание, что существуют и другие методы сегментации, такие как преобразование Хафа, обнаружение контуров и современная семантическая сегментация.

Связанные с: Классификация спутниковых изображений с использованием TensorFlow в Python.

Хотите узнать больше?
Вот некоторые полезные ресурсы, которые вы можете прочитать:

Кластеризация K-средних в OpenCV.
Введение в сегментацию изображений с кластеризацией K-Средних.
Наконец, я собрал несколько полезных курсов для дальнейшего обучения. Выдвигайся:

Курс глубокого обучения
Курс по сверточным нейронным сетям