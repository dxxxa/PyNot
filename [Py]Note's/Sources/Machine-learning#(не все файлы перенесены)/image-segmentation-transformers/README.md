# [How to Perform Image Segmentation using Transformers in Python](https://www.thepythoncode.com/article/image-segmentation-using-huggingface-transformers-python)
##
# [[] / []]()
–í —ç—Ç–æ–º —É—Ä–æ–∫–µ –º—ã —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏–º—Å—è –Ω–∞ —Ç–æ–º, –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫—É—é —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—é —Å –ø–æ–º–æ—â—å—é ü§ó –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ Transformers. –ö –∫–æ–Ω—Ü—É —ç—Ç–æ–≥–æ —É—á–µ–±–Ω–∏–∫–∞ —É –≤–∞—Å –±—É–¥–µ—Ç —á–µ—Ç–∫–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ —Ç–æ–º, –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ–¥—Ö–æ–¥—ã, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ –≥–ª—É–±–æ–∫–æ–º –æ–±—É—á–µ–Ω–∏–∏, –¥–ª—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π. –£ –≤–∞—Å –±—É–¥—É—Ç –Ω–∞–≤—ã–∫–∏, —á—Ç–æ–±—ã –ø—Ä–∏–º–µ–Ω–∏—Ç—å —ç—Ç–∏ –º–µ—Ç–æ–¥—ã –∫ –≤–∞—à–∏–º –ø—Ä–æ–µ–∫—Ç–∞–º.

–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∑–∞–ø–∏—Å–Ω—É—é –∫–Ω–∏–∂–∫—É Colab –¥–ª—è —ç—Ç–æ–≥–æ —É—á–µ–±–Ω–∏–∫–∞ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –∑–¥–µ—Å—å.

–°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —è–≤–ª—è–µ—Ç—Å—è –≤–∞–∂–Ω—ã–º —à–∞–≥–æ–º –≤ –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–º –∑—Ä–µ–Ω–∏–∏ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π. –û–Ω –¥–µ–ª–∏—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–≥–º–µ–Ω—Ç–æ–≤, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç, —Ñ–æ–Ω –∏–ª–∏ –æ–±–ª–∞—Å—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å–∞. –°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –∑–Ω–∞—á–∏–º—ã–µ –æ–±–ª–∞—Å—Ç–∏ –∏ –æ—Ç–¥–µ–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –æ—Ç —Ñ–æ–Ω–∞.

–°—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–º –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ–º —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, —á—Ç–æ –æ–Ω–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–µ –∑–∞–¥–∞—á–∏ –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–≥–æ –∑—Ä–µ–Ω–∏—è. –ù–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–∏ –æ–±—ä–µ–∫—Ç–æ–≤ –º—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, —á—Ç–æ–±—ã —Å—É–∑–∏—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â—É—é –æ–±–ª–∞—Å—Ç—å, —Ç–∞–∫ —á—Ç–æ –¥–µ—Ç–µ–∫—Ç–æ—Ä—É –æ–±—ä–µ–∫—Ç–æ–≤ –Ω—É–∂–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –æ–±–ª–∞—Å—Ç—å, –∞ –Ω–µ –≤—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –º—ã –º–æ–∂–µ–º —Å—ç–∫–æ–Ω–æ–º–∏—Ç—å –≤—Ä–µ–º—è –∏ –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã, —á—Ç–æ —á–∞—Å—Ç–æ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –ø–æ–≤—ã—à–µ–Ω–∏—é —Ç–æ—á–Ω–æ—Å—Ç–∏.

–î—Ä—É–≥–∏–º –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —è–≤–ª—è–µ—Ç—Å—è —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–æ–Ω–∞. –í–æ –º–Ω–æ–≥–∏—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è—Ö –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–≥–æ –∑—Ä–µ–Ω–∏—è –∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ –∏–∑–≤–ª–µ–∫–∞—Ç—å –æ–±—ä–µ–∫—Ç—ã –∏–∑ –∏—Ö —Ñ–æ–Ω–∞ –∏ –æ–ø–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–º–∏ —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ. –°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —É–¥–æ–±–Ω—ã–π —Å–ø–æ—Å–æ–± —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–∞ –ø–µ—Ä–µ–¥–Ω–∏–π –∏ —Ñ–æ–Ω–æ–≤—ã–π —Å–µ–≥–º–µ–Ω—Ç—ã.

–°—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Ç–æ–¥–æ–≤ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π, –Ω–∞—á–∏–Ω–∞—è –æ—Ç –ø–æ—Ä–æ–≥–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –¥–æ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ K-—Å—Ä–µ–¥–Ω–∏—Ö –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞—è –ø–æ–¥—Ö–æ–¥–∞–º–∏, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–º–∏ –Ω–∞ –≥–ª—É–±–æ–∫–æ–º –æ–±—É—á–µ–Ω–∏–∏. –í —ç—Ç–æ–º —É—Ä–æ–∫–µ –º—ã –±—É–¥–µ–º —Ä–∞–±–æ—Ç–∞—Ç—å —Å Segformer, –ø–æ–¥—Ö–æ–¥–æ–º, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–º –Ω–∞ –≥–ª—É–±–æ–∫–æ–º –æ–±—É—á–µ–Ω–∏–∏. Segformer —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –∏–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–æ–≥–æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä–Ω–æ–≥–æ —ç–Ω–∫–æ–¥–µ—Ä–∞, –∞ –¥–µ–∫–æ–¥–µ—Ä —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–µ–¥–∏–Ω–µ–Ω–Ω—ã—Ö —Å–ª–æ–µ–≤, —á—Ç–æ –ø–æ–≤—ã—à–∞–µ—Ç –µ–≥–æ —Ç–æ—á–Ω–æ—Å—Ç—å.

–°–≤—è–∑–∞–Ω–Ω—ã–µ —Å: –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—é K-Means –¥–ª—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å –ø–æ–º–æ—â—å—é OpenCV –≤ Python

–¢–∏–ø—ã —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
–°—É—â–µ—Å—Ç–≤—É–µ—Ç —Ç—Ä–∏ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ç–∏–ø–∞ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è, —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ –∏ –ø–∞–Ω–æ–ø—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è.

–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ –ø–∏–∫—Å–µ–ª—è –∏ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∫–∞–∂–¥–æ–≥–æ –ø–∏–∫—Å–µ–ª—è –Ω–∞ –ø—Ä–µ–¥–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–µ –∫–ª–∞—Å—Å—ã, —Ç–∞–∫–∏–µ –∫–∞–∫ ¬´—á–µ–ª–æ–≤–µ–∫¬ª, ¬´–∞–≤—Ç–æ–º–æ–±–∏–ª—å¬ª, ¬´–¥–µ—Ä–µ–≤–æ¬ª –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ. –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ —Ç–æ, —á—Ç–æ–±—ã –ø–æ–º–µ—Ç–∏—Ç—å –∫–∞–∂–¥—ã–π –ø–∏–∫—Å–µ–ª—å –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –µ–≥–æ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –∏ —Å–æ–∑–¥–∞—Ç—å —Å–µ–≥–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–µ–µ –æ–±—ä–µ–∫—Ç—ã –∏ –æ–±–ª–∞—Å—Ç–∏ –∏–Ω—Ç–µ—Ä–µ—Å–∞ –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏.

–°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ –≤–∫–ª—é—á–∞–µ—Ç –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—é –ø–∏–∫—Å–µ–ª–µ–π –≤ —Ä–∞–∑–ª–∏—á–Ω—ã–µ –∫–ª–∞—Å—Å—ã, –∞ —Ç–∞–∫–∂–µ —Ä–∞–∑–ª–∏—á–µ–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ –æ–¥–Ω–æ–≥–æ –∏ —Ç–æ–≥–æ –∂–µ –æ–±—ä–µ–∫—Ç–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–≤—É—Ö –∫–æ—à–µ–∫, –∫–∞–∂–¥–æ–π –∫–æ—à–∫–µ –±—É–¥–µ—Ç –ø—Ä–∏—Å–≤–æ–µ–Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è –º–µ—Ç–∫–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞. –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –ø–æ–ª—É—á–∏—Ç—å –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ–± –æ–±—ä–µ–∫—Ç–∞—Ö –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏, –ø–æ—Å–∫–æ–ª—å–∫—É –º–æ–¥–µ–ª—å —Ç–µ–ø–µ—Ä—å —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç —Ä–∞–∑–ª–∏—á–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –æ–¥–Ω–æ–≥–æ –∏ —Ç–æ–≥–æ –∂–µ –∫–ª–∞—Å—Å–∞.

–ü–∞–Ω–æ–ø—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏—é —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π –∏ –∏–Ω—Å—Ç–∞–Ω—Å–Ω–æ–π —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä—É—é—Ç—Å—è, –∏ –≤—Å–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –∫–∞–∂–¥–æ–≥–æ –∫–ª–∞—Å—Å–∞ —Ç–∞–∫–∂–µ —Ä–∞–∑–¥–µ–ª—è—é—Ç—Å—è. –≠—Ç–æ —Ç–∞–∫–∂–µ –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—é —Ñ–æ–Ω–∞! –≠—Ç–æ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –≤—Å–µ—Å—Ç–æ—Ä–æ–Ω–Ω–µ–º—É –∏ –ø–æ–ª–Ω–æ–º—É –ø–æ–Ω–∏–º–∞–Ω–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏, —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, —è–≤–ª—è–µ—Ç—Å—è –Ω–∞–∏–±–æ–ª–µ–µ –æ–±—â–∏–º —Å–ª—É—á–∞–µ–º —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏.

–õ–∞–¥–Ω–æ, —Ö–≤–∞—Ç–∏—Ç —Å–æ –≤—Å–µ—Ö —Ä–∞–∑–≥–æ–≤–æ—Ä–æ–≤. –î–∞–≤–∞–π—Ç–µ —Å—Ä–∞–∑—É –∂–µ —É–≥–ª—É–±–∏–º—Å—è –≤ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å–∞–º–∏!

–°–Ω–∞—á–∞–ª–∞ –º—ã —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É transformers, –≤—ã–ø–æ–ª–Ω–∏–≤ —Å–ª–µ–¥—É—é—â—É—é –∫–æ–º–∞–Ω–¥—É.

$ pip install requests Pillow numpy torch torchvision transformers
–ï—Å–ª–∏ –≤—ã –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –Ω–∞ Colab, –ø—Ä–æ—Å—Ç–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä—ã:

$ pip install transformers
–ù–∞—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å PyTorch —Å –ø–æ–º–æ—â—å—é –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–∞. –î–∞–≤–∞–π—Ç–µ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:

import numpy as np
import torch
import torch.nn.functional as F
from torchvision import transforms
from transformers import pipeline, SegformerImageProcessor, SegformerForSemanticSegmentation
import requests
from PIL import Image
import urllib.parse as parse
import os
–ó–∞—Ç–µ–º –¥–µ–ª–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –º—ã —Ö–æ—Ç–∏–º –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:

# a function to determine whether a string is a URL or not
def is_url(string):
    try:
        result = parse.urlparse(string)
        return all([result.scheme, result.netloc, result.path])
    except:
        return False

# a function to load an image
def load_image(image_path):
    """Helper function to load images from their URLs or paths."""
    if is_url(image_path):
        return Image.open(requests.get(image_path, stream=True).raw)
    elif os.path.exists(image_path):
        return Image.open(image_path)

img_path = "https://shorthaircatbreeds.com/wp-content/uploads/2020/06/Urban-cat-crossing-a-road-300x180.jpg"
image = load_image(img_path)
image
–í–æ—Ç —Å –∫–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –º—ã –±—É–¥–µ–º —Ä–∞–±–æ—Ç–∞—Ç—å:



–û–±–µ –≤—ã—à–µ—É–∫–∞–∑–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±—ã–ª–∏ –≤–∑—è—Ç—ã –∏–∑ —É—á–µ–±–Ω–∏–∫–∞ –ø–æ —Å—É–±—Ç–∏—Ç—Ä–∞–º –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º, is_url() –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ URL-–∞–¥—Ä–µ—Å–æ–º. load_image() –∑–∞–≥—Ä—É–∑–∏—Ç –∏ –∑–∞–≥—Ä—É–∑–∏—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –µ—Å–ª–∏ —ç—Ç–æ URL-–∞–¥—Ä–µ—Å, –∏ –∑–∞–≥—Ä—É–∑–∏—Ç –µ–≥–æ, –µ—Å–ª–∏ —ç—Ç–æ –ª–æ–∫–∞–ª—å–Ω—ã–π –ø—É—Ç—å.

# convert PIL Image to pytorch tensors
transform = transforms.ToTensor()
image_tensor = image.convert("RGB")
image_tensor = transform(image_tensor)
–ú—ã —Ç–∞–∫–∂–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ PIL –≤ —Ç–µ–Ω–∑–æ—Ä PyTorch, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –≤ –±—É–¥—É—â–µ–º.

–¢–µ–ø–µ—Ä—å –æ–ø—Ä–µ–¥–µ–ª–∏–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –æ–±–ª–µ–≥—á–∞—Ç –Ω–∞—à—É –∂–∏–∑–Ω—å:

def color_palette():
  """Color palette to map each class to its corresponding color."""
  return [[0, 128, 128],
          [255, 170, 0],
          [161, 19, 46],
          [118, 171, 47],
          [255, 255, 0],
          [84, 170, 127],
          [170, 84, 127],
          [33, 138, 200],
          [255, 84, 0]]
–§—É–Ω–∫—Ü–∏—è color_palette() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ü–≤–µ—Ç–æ–≤, —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö—Å—è –≤ –≤–∏–¥–µ –∑–Ω–∞—á–µ–Ω–∏–π RGB. –≠—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Ü–≤–µ—Ç —Å–µ–≥–º–µ–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –º—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å.

def overlay_segments(image, seg_mask):
  """Return different segments predicted by the model overlaid on image."""
  H, W = seg_mask.shape
  image_mask = np.zeros((H, W, 3), dtype=np.uint8)
  colors = np.array(color_palette())
  # convert to a pytorch tensor if seg_mask is not one already
  seg_mask = seg_mask if torch.is_tensor(seg_mask) else torch.tensor(seg_mask)
  unique_labels = torch.unique(seg_mask)
  # map each segment label to a unique color
  for i, label in enumerate(unique_labels):
    image_mask[seg_mask == label.item(), :] = colors[i]
  image = np.array(image)
  # percentage of original image in the final overlaid iamge
  img_weight = 0.5 
  # overlay input image and the generated segment mask
  img = img_weight * np.array(image) * 255 + (1 - img_weight) * image_mask
  return img.astype(np.uint8)
–§—É–Ω–∫—Ü–∏—è overlay_segment() –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏ –º–∞—Å–∫—É —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å–∫—É, –Ω–∞–ª–æ–∂–µ–Ω–Ω—É—é –ø–æ–≤–µ—Ä—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –°–Ω–∞—á–∞–ª–∞ –æ–Ω –∑–∞–º–µ–Ω—è–µ—Ç –∫–∞–∂–¥—É—é –º–µ—Ç–∫—É –∫–ª–∞—Å—Å–∞ –∑–Ω–∞—á–µ–Ω–∏–µ–º RGB –∏–∑ —Ü–≤–µ—Ç–æ–≤–æ–π –ø–∞–ª–∏—Ç—Ä—ã, –∫–æ—Ç–æ—Ä—É—é –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –≤—ã—à–µ. –ó–∞—Ç–µ–º –±–µ—Ä–µ—Ç—Å—è —Å—Ä–µ–¥–Ω–µ–≤–∑–≤–µ—à–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ –Ω–∞—à–µ–π –º–∞—Å–∫–∏ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏.

def replace_label(mask, label):
  """Replace the segment masks values with label."""
  mask = np.array(mask)
  mask[mask == 255] = label
  return mask
–ù–∞–∫–æ–Ω–µ—Ü, —Ñ—É–Ω–∫—Ü–∏—è replace_label() –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –¥–≤–æ–∏—á–Ω—É—é –º–∞—Å–∫—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ numpy —Å –º–µ—Ç–∫–æ–π. –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª–Ω–æ–π –º–∞—Å–∫–∏ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –º–∞—Å–æ–∫.

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ API –∫–æ–Ω–≤–µ–π–µ—Ä–∞
–¢–µ–ø–µ—Ä—å —Å–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π —Å–ø–æ—Å–æ–± —Ä–µ—à–∏—Ç—å –ª—é–±—É—é –∑–∞–¥–∞—á—É –Ω–∞ ü§ó —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä–∞—Ö ‚Äì –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥ —Ç—Ä—É–±–æ–ø—Ä–æ–≤–æ–¥–∞()! –ü–æ—ç—Ç–æ–º—É –º—ã –Ω–∞—á–∏–Ω–∞–µ–º —Å –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω–≤–µ–π–µ—Ä–∞ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π –º–æ–¥–µ–ª–∏, –∫–æ—Ç–æ—Ä—É—é –º—ã —Ö–æ—Ç–∏–º –∑–∞–≥—Ä—É–∑–∏—Ç—å. –ó–∞—Ç–µ–º –º—ã –ø–µ—Ä–µ–¥–∞–µ–º –µ–º—É –≤—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ PIL –∏ –ø–æ–ª—É—á–∞–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –º–∞—Å–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª–∞—Å—Å–∞:

# load the entire image segmentation pipeline
img_segmentation_pipeline = pipeline('image-segmentation', 
                                     model="nvidia/segformer-b5-finetuned-ade-640-640")
output = img_segmentation_pipeline(image)
output
–í—ã–ø—É—Å–∫:

[{'score': None,
  'label': 'building',
  'mask': <PIL.Image.Image image mode=L size=300x180 at 0x7FA03605DDF0>},
 {'score': None,
  'label': 'floor',
  'mask': <PIL.Image.Image image mode=L size=300x180 at 0x7FA03605D7C0>},
 {'score': None,
  'label': 'road',
  'mask': <PIL.Image.Image image mode=L size=300x180 at 0x7FA035F9CF70>},
 {'score': None,
  'label': 'person',
  'mask': <PIL.Image.Image image mode=L size=300x180 at 0x7FA037FA9100>},
 {'score': None,
  'label': 'car',
  'mask': <PIL.Image.Image image mode=L size=300x180 at 0x7FA037FA9370>},
 {'score': None,
  'label': 'plaything',
  'mask': <PIL.Image.Image image mode=L size=300x180 at 0x7FA16A93CD30>},
 {'score': None,
  'label': 'minibike',
  'mask': <PIL.Image.Image image mode=L size=300x180 at 0x7FA036074A30>}]
–ú—ã –º–æ–∂–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –º–∞—Å–∫—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è PIL —Å –∏–Ω–¥–µ–∫—Å–æ–º 0 —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:

output[0]['mask']


–†–∞–∑–≤–µ –Ω–µ –±—ã–ª–æ –±—ã –∑–¥–æ—Ä–æ–≤–æ, –µ—Å–ª–∏ –±—ã –º—ã –º–æ–≥–ª–∏ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –º–∞—Å–∫–∏ –¥–ª—è –≤—Å–µ—Ö –∫–ª–∞—Å—Å–æ–≤ –∑–∞ –æ–¥–∏–Ω —Ä–∞–∑? –î–∞–≤–∞–π—Ç–µ —Å–¥–µ–ª–∞–µ–º —ç—Ç–æ:

# load the feature extractor (to preprocess images) and the model (to get outputs)
W, H = image.size
segmentation_mask = np.zeros((H, W), dtype=np.uint8)

for i in range(len(output)):
  segmentation_mask += replace_label(output[i]['mask'], i)
–ü–æ—Å–ª–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –º–∞—Å–æ–∫ –º—ã –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∞–ª–æ–∂–µ–Ω–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã.

# overlay the predicted segmentation masks on the original image
segmented_img = overlay_segments(image_tensor.permute(1, 2, 0), segmentation_mask)

# convert to PIL Image
Image.fromarray(segmented_img)
–í—É–∞–ª—è! –≠—Ç–æ —Å–µ–≥–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –¥–∞–ª–∞ –Ω–∞–º –Ω–∞—à–∞ –º–æ–¥–µ–ª—å:



–¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –º—ã –∑–Ω–∞–µ–º, –∫–∞–∫ —Ä–∞–±–æ—Ç–∞—Ç—å —Å –∫–æ–Ω–≤–µ–π–µ—Ä–æ–º, –¥–∞–≤–∞–π—Ç–µ —Å–¥–µ–ª–∞–µ–º —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–æ–Ω–≤–µ–π–µ—Ä–∞.

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ ü§ó –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –º–æ–¥–µ–ª–µ–π —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä–æ–≤
–í–æ-–ø–µ—Ä–≤—ã—Ö, –º—ã –∑–∞–≥—Ä—É–∑–∏–º –Ω–∞—à—É —Ç–æ—á–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å –∏ —ç–∫—Å—Ç—Ä–∞–∫—Ç–æ—Ä —Ñ—É–Ω–∫—Ü–∏–π. –ú—ã –≤—ã–±–∏—Ä–∞–µ–º nvidia/segformer-b5-finetuned-ade-640-640, –∫–æ—Ç–æ—Ä–∞—è —è–≤–ª—è–µ—Ç—Å—è –º–æ–¥–µ–ª—å—é SegFormer, —Ç–æ—á–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π –Ω–∞ –Ω–∞–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π ADE20k (–±–æ–ª–µ–µ 20K –æ–±—Ä–∞–∑—Ü–æ–≤) —Å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ–º 640x640. –û–Ω –±—ã–ª –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω NVIDIA –≤ —ç—Ç–æ–π —Å—Ç–∞—Ç—å–µ.

–ù–∏–∂–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ SegFormer, –≥–¥–µ –∫–æ–¥–∏—Ä–æ–≤—â–∏–∫ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä–Ω—ã—Ö –±–ª–æ–∫–æ–≤, –∞ –¥–µ–∫–æ–¥–µ—Ä ‚Äî –ø—Ä–æ—Å—Ç–æ MLP (–ú–Ω–æ–≥–æ—Å–ª–æ–π–Ω—ã–µ –ø–µ—Ä—Å–µ–ø—Ç—Ä–æ–Ω—ã):

SegFormer –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞–†–∏—Å—É–Ω–æ–∫ 1: SegFormer Architecture –∏–∑ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π —Å—Ç–∞—Ç—å–∏.

 

–≠–∫—Å—Ç—Ä–∞–∫—Ç–æ—Ä –æ–±—ä–µ–∫—Ç–æ–≤ –±–µ—Ä–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –µ–≥–æ, —á—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –ø–µ—Ä–µ–¥–∞—Ç—å –µ–≥–æ –Ω–∞—à–µ–π –º–æ–¥–µ–ª–∏:

# load the feature extractor (to preprocess images) and the model (to get outputs)
feature_extractor = SegformerImageProcessor.from_pretrained("nvidia/segformer-b5-finetuned-ade-640-640")
model = SegformerForSemanticSegmentation.from_pretrained("nvidia/segformer-b5-finetuned-ade-640-640")
–î–∞–ª–µ–µ, –ø—Ä–∏–≤–µ–¥–µ–Ω–Ω—ã–π –Ω–∏–∂–µ –∫–æ–¥ –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏:

def to_tensor(image):
  """Convert PIL Image to pytorch tensor."""
  transform = transforms.ToTensor()
  image_tensor = image.convert("RGB")
  image_tensor = transform(image_tensor)
  return image_tensor

# a function that takes an image and return the segmented image
def get_segmented_image(model, feature_extractor, image_path):
  """Return the predicted segmentation mask for the input image."""
  # load the image
  image = load_image(image_path)
  # preprocess input
  inputs = feature_extractor(images=image, return_tensors="pt")
  # convert to pytorch tensor
  image_tensor = to_tensor(image)
  # pass the processed input to the model
  outputs = model(**inputs)
  print("outputs.logits.shape:", outputs.logits.shape)
  # interpolate output logits to the same shape as the input image
  upsampled_logits = F.interpolate(
      outputs.logits, # tensor to be interpolated
      size=image_tensor.shape[1:], # output size we want
      mode='bilinear', # do bilinear interpolation
      align_corners=False)

  # get the class with max probabilities
  segmentation_mask = upsampled_logits.argmax(dim=1)[0]
  print(f"{segmentation_mask.shape=}")
  # get the segmented image
  segmented_img = overlay_segments(image_tensor.permute(1, 2, 0), segmentation_mask)
  # convert to PIL Image
  return Image.fromarray(segmented_img)
–í get_segmented_image() –º—ã –¥–µ–ª–∞–µ–º —Å–ª–µ–¥—É—é—â–µ–µ:

–ú—ã –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é feature_extractor.
–ú—ã –ø–µ—Ä–µ–¥–∞–µ–º –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–∏–∫—Å–µ–ª–µ–π –≤ –Ω–∞—à—É –º–æ–¥–µ–ª—å –¥–ª—è –≤—ã–≤–æ–¥–∞, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.
–ó–∞—Ç–µ–º –º—ã –∏–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º –≤—ã—Ö–æ–¥–Ω—ã–µ –º–∞—Å–∫–∏ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –º–∞—Å–∫–∏ —Ç–æ–≥–æ –∂–µ —Ä–∞–∑–º–µ—Ä–∞, —á—Ç–æ –∏ –Ω–∞—à–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–∏ F.interpolate() PyTorch.
–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –º—ã –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –∫–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∏–∫—Å–µ–ª—è –≤ –Ω–∞—à–∏—Ö –º–∞—Å–∫–∞—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º—É –∫–ª–∞—Å—Å—É.
–ü–æ–ª—É—á–∏–≤ –º–∞—Å–∫–∏, –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞–ª–æ–∂–µ–Ω–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã.
–¢–µ–ø–µ—Ä—å –≤–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è —Ñ—É–Ω–∫—Ü–∏–µ–π:

get_segmented_image(model, feature_extractor, "https://shorthaircatbreeds.com/wp-content/uploads/2020/06/Urban-cat-crossing-a-road-300x180.jpg")
–ü–æ–ª—É—á–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:



–î—Ä—É–≥–æ–π –ø—Ä–∏–º–µ—Ä:

get_segmented_image(model, feature_extractor, "http://images.cocodataset.org/test-stuff2017/000000000001.jpg")
–í—ã–ø—É—Å–∫:



–£—Ä–∞! –ù–∞—à–∞ –º–æ–¥–µ–ª—å —Ä–∞–±–æ—Ç–∞–µ—Ç —Ö–æ—Ä–æ—à–æ. –¢–µ–ø–µ—Ä—å –≤—ã –∑–Ω–∞–µ—Ç–µ, –∫–∞–∫ —Å–¥–µ–ª–∞—Ç—å —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ. –í —ç—Ç–æ–º —É—Ä–æ–∫–µ –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –º–æ–¥–µ–ª—å nvidia/segformer-b5-finetuned-ade-640-640 –æ—Ç ü§ó Transformers. –í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–µ –¥—Ä—É–≥–∏–µ –º–æ–¥–µ–ª–∏ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ.

–°—Å—ã–ª–∫–∏ –∏ –ø–æ–ª–µ–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏
–¢–æ–Ω–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ–¥–µ–ª–∏ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ —Å –ø–æ–º–æ—â—å—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
–°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è - Huggingface
–ú–æ–¥–µ–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ NVIDIA SegFormer
–ò—Å—Ç–æ—á–Ω–∏–∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: –ö–æ—Ä–æ—Ç–∫–æ—à–µ—Ä—Å—Ç–Ω—ã–µ –ø–æ—Ä–æ–¥—ã –∫–æ—à–µ–∫
–ß—Ç–æ–±—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ–ª–Ω—ã–π –∫–æ–¥, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —ç—Ç—É —Å—Å—ã–ª–∫—É.