# [How to Make a Real-Time GUI Spelling Checker in Python](https://www.thepythoncode.com/article/make-a-realtime-spelling-checker-gui-python)
##
# [[] / []]()
Написание всегда было трудной задачей, и одно можно сказать наверняка, когда вы пишете, орфографические ошибки в написании некоторых слов неизбежны, и в то же время заметить эти ошибки также трудно. В наши дни письмо было упрощено таким образом, что у нас есть множество инструментов, чтобы облегчить наши письменные задачи для нас. У нас есть инструменты для перефразирования предложений, генерации как введений, так и выводов, обобщения абзацев, проверки и исправления грамматики и т. Д. Эти инструменты хороши, но одним из общих недостатков, которые у них есть, являются их цены, они дорогие, поэтому, если вы не можете себе этого позволить, то создание вашего инструмента будет отличным и стоит того.

В этом учебнике мы создадим средство проверки орфографии в реальном времени с графическим интерфейсом с использованием библиотек NLTK, re и Tkinter. Это приложение, которое будет проверять ваши предложения на наличие грамматических ошибок в режиме реального времени при вводе прокручиваемого текстового поля. Этот туториал предназначен для вас, если вы хотите узнать, как создать средство проверки орфографии в реальном времени с графическим интерфейсом в Python. Вот что мы будем строить:



Этот учебник научит так много концепций программирования, таких как создание графического интерфейса с помощью Tkinter, реализация событий и работа с API nltk. Мы создадим каждую часть приложения с нуля, чтобы вы могли изучить все рассматриваемые концепции. Так что, если вы взволнованы, давайте начнем!

Вот оглавление:

Необходимые условия
Начало работы
Импорт всех необходимых модулей
Создание класса приложения
Проектирование графического интерфейса пользователя
Создание главного окна и добавление его значка
Добавление текстовой метки
Добавление прокрученного текста
Реализация функции закрытия приложения
Реализация функции проверки орфографии в режиме реального времени
Заключение
Необходимые условия
Чтобы вы могли легко следовать и максимально использовать этот учебник, вы должны иметь хотя бы некоторые знания объектно-ориентированного программирования, поскольку мы создадим приложение с использованием этого подхода.

Начало работы
Первой задачей, которая заставит нас работать, будет установка необходимого модуля для этого проекта, остальные модули предварительно установлены в Python, поэтому не нужно беспокоиться. Откройте терминал и выполните следующую команду:

$ pip install nltk
Импорт всех необходимых модулей
Теперь, когда мы успешно установили необходимый модуль, мы импортируем его вместе с другими модулями. Создайте новый файл и назовите его spellingchecker.py или любым именем, которое вы предпочитаете, чтобы он был осмысленным, в него вставьте следующий код:

# this imports everything from the tkinter module
from tkinter import *
# importing the ttk module from tkinter that's for styling widgets
from tkinter import ttk
# importing a Text field with the scrollbar
from tkinter.scrolledtext import ScrolledText
# imports the re module
import re
# this imports nltk
import nltk
# importing all the words from nltk
from nltk.corpus import words
В приведенном выше коде мы импортируем все из tkinter с помощью звездочки (*), затем мы импортируем модуль стиля ttk.

Чтобы использовать ScrolledText, мы импортируем его из tkinter.scrolledtext. Мы также импортировали модуль re для манипулирования словами и для проверки орфографии мы импортировали модуль nltk, у нас также есть учебник по nltk здесь. Наконец, мы импортируем все слова из ntlk.corpus, эти слова будут использоваться для сравнения с ошибками в приложении

Создание класса приложения
Как упоминалось ранее, мы построим приложение, используя объектно-ориентированный подход программирования, под этим мы подразумеваем структурирование программы путем объединения связанных свойств и поведения в отдельные объекты. Итак, давайте создадим класс для приложения, под импортом добавим этот код:

# we are creating a SpellingChecker class
class SpellingChecker:
    # a special method, always called when an instance is created
    def __init__(self, master):
        # do nothing for the meantime
        pass
Чтобы быть на одной странице, давайте разберем приведенный выше код, мы создадим класс под названием SpellingChecker, который пока ничего не делает, и внутри него у нас есть специальная функция __init__(), принимая себя и master в качестве аргументов.

Обратите внимание, что каждая функция внутри класса будет принимать себя в качестве своего первого аргумента, а функция __init__() вызывается при создании экземпляра или объекта. А под классом вставьте следующий код:

# creating the root winding using Tk() class
root = Tk()
# instantiating/creating object app for class SpellingChecker 
app = SpellingChecker(root)
# calling the mainloop to run the app infinitely until user closes it
root.mainloop()
Здесь мы просто создаем главное окно с помощью встроенного класса Tkinter Tk(), затем мы создаем объект класса с именем app, обратите внимание, что мы передаем корень классу, это то же самое, что и master внутри класса. Наконец, мы вызываем функцию mainloop(), которая запускает приложение бесконечно, пока пользователь не закроет его.

Теперь для запуска приложения используйте:

$ python spellingchecker.py
Или некоторые редакторы кода поставляются с интерпретаторами Python для запуска программ Python, просто используйте это вместо этого.

И вот что вы получите:



Здесь мы получаем маленькое и не очень привлекательное окно, потому что мы ничего не создали в классе. Мы будем работать над окном буквально через мгновение, но самое главное, что программа работает нормально.

Здесь стоит упомянуть: все, что касается приложения, будет создано внутри класса.

Проектирование графического интерфейса пользователя
В этом разделе мы увидим силу Tkinter, когда дело доходит до разработки шикарных графических пользовательских интерфейсов. Процесс проектирования будет глубоким, чтобы вы понимали наиболее важные концепции в Tkinter.

Создание главного окна и добавление его значка
Теперь мы будем работать над маленьким и не очень привлекательным окном, которое мы видели минуту назад, мы увеличим его, дадим ему название и добавим к нему иконку. Поэтому внутри функции __init__() удалите ключевое слово pass и добавьте следующий код:

        # creating the main window
        self.master = master
        # giving title to the main window
        self.master.title('Real-Time Spelling Checker')
        # defining dimensions and position for the main window
        self.master.geometry('580x500+440+180')
        # adding an icon to the main window
        self.master.iconbitmap(self.master, 'spell-check.ico')
        # making the main window non-resizable
        self.master.resizable(height=FALSE, width=FALSE)
В фрагменте кода мы объявляем мастер, который будет заменен корнем. Затем у нас есть функция title(), которая принимает строку в качестве аргумента, это для заголовка главного окна. Функция geometry() предназначена для размеров и положения главного окна, 580x500 - для ширины и высоты и 440 + 180 - для горизонтального и вертикального расположения главного окна.

Чтобы добавить иконку в главное окно, у нас есть функция iconbitmap(), принимающая мастер и иконку в качестве аргументов. Наконец, у нас есть функция variable() с высотой и шириной, установленными на FALSE, что это сделает, так это отключит кнопку развернуть / свернуть главное окно.

Запустив программу, вы получите такой вывод:



А в левом верхнем углу окна добавлена иконка и заголовок:



Здесь просто убедитесь, что файл значка находится в той же папке, что и файл программы:



Добавление текстовой метки
Теперь мы добавим метку для отображения большого текста, но прежде чем мы создадим ее, давайте сначала определим ее класс стиля. Чуть выше этой строки кода:

        self.master = master
Вставьте следующие строки кода:

        # defining a style for the label
        style = ttk.Style()
        # configuring the style, TLabel is the style name
        style.configure('TLabel', foreground='#000000', font=('OCR A Extended', 25))
Затем под кодом главного окна вставьте следующий код:

        # creating the label to display the big text
        self.label = ttk.Label(self.master, text='Real-Time Spelling Checker', style='TLabel')
        # adding the label to the main window using grid geometry manager
        self.label.grid(row=0, column=0, columnspan=10, padx=5, pady=25)
Мы создаем метку ttk с помощью ttk. Функция Label(), она принимает self.master, текст и стиль в качестве аргументов. Чтобы поместить метку в главное окно, мы используем функцию grid(), аргументами которой являются строка, столбец, столбец, padx и pady. В нашем случае метка занимает 0-ю строку, 0-й столбец, и она охватывает до 10 столбцов, и она заполняется 5 пикселями по вертикали и 25 пикселей по горизонтали.

Вывод добавленного выше кода выглядит следующим образом:



На данный момент не беспокойтесь о внешнем виде приложения, оно примет свою полную форму, когда мы добавим некоторые виджеты.

Добавление прокрученного текста
Давайте добавим поле ScrolledText, это просто текстовое поле с полосой прокрутки на нем. Под кодом метки вставьте следующий код:

        # creating a scollable Text field
        self.text = ScrolledText(self.master, font=("Helvetica", 15), width=50, height=15)
        # bing the scrollable Text field to an event
        self.text.bind('<KeyRelease>', self.check)
        # adding the scrollable Text field to the main window using grid geometry manager
        self.text.grid(row=1, column=0, padx=5, pady=5, columnspan=10)
С помощью приведенного выше фрагмента кода мы создаем ScrolledText с помощью функции ScrolledText(), которая принимает self.master, шрифт, ширину и высоту в качестве аргументов. Затем мы привязываем его к событию KeyRelease, это будет иметь больше смысла через мгновение. Наконец, мы добавляем виджет в главное окно через функцию grid(), помещаем его в 1-ю строку, 0-й столбец, заполняя его 5 и 10 пикселей по вертикали и горизонтали соответственно, и он охватывает до 10 столбцов.

Если вы запустите программу, вы получите следующие выходные данные:



Если вы попытаетесь добавить несколько длинных абзацев в ScrolledText, полоса прокрутки будет выглядеть следующим образом:



Хорошая вещь об этом виджете заключается в том, что он уже интегрирован с полосой прокрутки, в то время как с виджетом «Текст» вам нужно явно добавить к нему полосу прокрутки, что утомительно, потому что требует много кодирования.

Реализация функции закрытия приложения
Дорабатывая графический интерфейс, давайте дадим возможность приложению спросить пользователя, закрывать его или нет одним нажатием кнопки. Под последней строкой импорта добавьте следующий код:

# importing an askyesno message box from tkinter.message
from tkinter.messagebox import askyesno
Здесь мы просто импортируем окно сообщения askyesno из tkinter.messagebox.

Теперь создадим функцию для обработки функциональности закрытого приложения, внутри класса под функцией __init__() вставьте этот код:

    # the function for closing the application
    def close(self):
        # this will ask the user whether to close or not
        # if the value is yes/True the window will close
        if askyesno(title='Close Real-Time Spelling Checker', message='Are you sure you want to close the application?'):
            # this destroys the window
            self.master.destroy()
Это то, что происходит в коде, у нас есть функция под названием close(), принимающая себя в качестве аргумента. У нас есть окно сообщения askyesno, которое вычисляет в два логических значения True или False.

Если пользователь предоставляет значение yes, которое имеет значение True, будет выполнена функция destroy(), и главное окно будет закрыто. Если значение askyesno равно False, окно все равно будет запущено.

Создания функции недостаточно, нам нужно привязать ее к главному окну, чтобы прослушать событие закрытия окна. Итак, ниже этой строки:

        self.master.resizable(height=FALSE, width=FALSE)
Добавьте следующую строку кода:

        # this is for closing the window via the close() function
        self.master.protocol('WM_DELETE_WINDOW', self.close)
В этой строке кода функция protocol() принимает WM_DELETE_WINDOW и функцию close в качестве аргументов, чтобы указать на функцию, которую мы используем ключевое слово self. С помощью WM_DELETE_WINDOW функция будет прослушивать событие закрытия главного окна, которое выдается всякий раз, когда пользователь нажимает кнопку закрытия в главном окне.

Если событие обнаружено, выполняется функция close() и появляется окно сообщения askyesno, если пользователь нажимает кнопку «Да», окно закрывается, а если нет, то окно все равно запускается.

Давайте протестируем эту функциональность, запустим программу, и вы получите следующий вывод:



Поздравляем с успешным созданием графического интерфейса приложения!

Реализация функции проверки орфографии в режиме реального времени
Разработки графического интерфейса для приложения недостаточно, но настоящая радость приходит, когда вы заставляете его выполнять свою предназначенную функцию. В этом разделе мы будем реализовывать функцию проверки орфографии в режиме реального времени. Таким образом, внутри класса создайте функцию с именем check(), как в приведенном ниже фрагменте кода:

    # this is the function for checking spelling in real-time
    def check(self, event):
        print('Hello am a real time checker')
Приведенная выше функция принимает себя и событие в качестве аргументов. У нас есть функция print() для печати текста на терминале. Отредактируйте эту строку кода:

        self.text.bind('<KeyRelease>')
И сделать так, чтобы это выглядело так:

        self.text.bind('<KeyRelease>', self.check)
Вот что происходит, мы передаем событие и self.check в функцию bind. Переданная функция будет активирована после того, как произошло событие. В нашем случае событием является KeyRelease, что означает, что функция check() будет выполняться после каждого выпуска ключа в ScrolledText.

Давайте протестируем это, запустим программу и начнем вводить в ScrolledText, вывод в вашей консоли будет следующим:



Мы хотим, чтобы приложение могло проверять орфографию в режиме реального времени и при нажатии клавиши пробела. Теперь, когда вы увидели, как события пригодятся при выполнении задач в режиме реального времени, давайте реализуем фактическую функциональность приложения.

Итак, над классом вставьте следующую строку кода:

# this will download the words
nltk.download('words')
Эта строка кода предназначена для загрузки всех слов, и мы будем использовать эти слова для проверки с ошибками в приложении.

Запустите программу, и вы получите следующие выходные данные в своей консоли:



Обратите внимание, что каждый раз, когда вы запускаете программу, она всегда будет загружать набор данных слов из библиотеки nltk.

Мы создадим переменную для отслеживания пробелов в словах, поэтому под кодом стиля вставьте этот код:

        # variable for tracking white space, default is 0
        self.old_spaces = 0
Его значение по умолчанию равно 0. Под функцией close() вставьте следующий код:

# this is the function for checking spelling in real-time
def check(self, event):
    # getting all the content from the ScrolledText via get() function
    # 1.0 is the starting point and END is the end point of the ScrolledText content 
    content = self.text.get('1.0', END)
    # getting all the white spaces from the content
    space_count = content.count(' ')
    # checking if the space_count is not equal to self.old_spaces
    if space_count != self.old_spaces:
        # updating the self.old_spaces to space_count
        self.old_spaces = space_count
        # this loops through all the tag names
        # and deletes them if the word is valid
        for tag in self.text.tag_names():
            self.text.tag_delete(tag)
        # splitting the content by white space
        # and looping through the split content to get a single word
        for word in content.split(' '):
            # with the sub() function we are removing special characters from the word
            # replacing the special character with nothing
            # the target is word.lower()
            # checking if the cleaned lower case word is not in words
            if re.sub(r'[^\w]', '', word.lower()) not in words.words():
                # gets the position of the invalid word
                position = content.find(word)
                # adding a tag to the invalid word
                self.text.tag_add(word, f'1.{position}', f'1.{position + len(word)}')
                # changing the color of the invalid word to red
                self.text.tag_config(word, foreground='red')
Разобьем код внутри функции check(), аргументами которой являются self и event:

Во-первых, мы получаем каждый символ из ScrolledText через функцию get(), 1.0 является отправной точкой символов, а END - конечной точкой символов.
Чтобы получить все пробелы из контента, мы используем content.count(' ')
У нас есть оператор if, который проверяет, не равен ли space_count self.old_spaces, если это True, мы обновляем self.old_spaces до space_count.
Первый цикл for внутри оператора if просматривает все имена тегов и удаляет их из прикрепленного слова, если оно имеет правильное написание.
Со вторым циклом for мы разделяем содержимое ScrolledText через content.split(' '), затем мы зацикливаемся на разделенном содержимом и получаем доступ к одному слову.
Затем у нас есть еще один оператор if для проверки достоверности слова, у нас есть функция re.sub(), которая получает все специальные символы и заменяет их пустой строкой на слове в нижнем регистре.
Если слово недопустимо, мы получаем его позицию через функцию content.find() и добавляем к ней от первого до последнего символа
Наконец, мы добавляем цвет к слову, используя функцию tag_config(), которая принимает слово и передний план в качестве аргументов.
Теперь мы настроены на тестирование приложения, давайте запустим программу и наберем предложение с некоторыми словами с ошибками, это вывод, который мы получим:



На этот раз давайте попробуем предложение без слов с ошибками, результат, который вы получите, выглядит следующим образом:



Прекрасно! Приложение работает как положено!

Как вы заметили, приложение начинается с загрузки всех слов и, чтобы проверить орфографию слова, нажмите клавишу пробела.

Заключение
Вот и все из этого урока, мы надеемся, что вам понравилось. Этот учебник проведет вас через процесс кодирования проверки орфографии в реальном времени с графическим интерфейсом с использованием Python с нуля до полнофункционального приложения.

Мы надеемся, что вы многому научились из этого учебника и что знания, которые вы приобрели, будут полезны в ваших будущих проектах Python. Спасибо, что следите за новостями.

Вы можете получить полный код здесь.