# [How to Use Hash Algorithms in Python using hashlib](https://www.thepythoncode.com/article/hashing-functions-in-python-using-hashlib)
To hash a checksum of the file `foo.pdf`:
    
    python hashing_files.py foo.pdf
    
**Outputs:**
    
    MD5: 49260116db5c6dab4cda627fbc6e6455
    SHA-256: 7d6c24e45b38375e322419281cee1335ddb97e00fc86abe9f22afcd8b42e6d82
    SHA-512: dd7bdd49300fc2aa76babb4afada70621f35235ff472342fb6efef7150b840ad06c1e081fa20469fc4801139939ce18a3c891f4ca15a45e31d487160b2e6f22e
    SHA-3-256: 975ef59e80d7eefa5068f7876fa63139436f47582cc7c29d3540c85d241e16be
    SHA-3-512: 07b8ee04cd2ac390ac6fc4f1598083347ae001d4cc8ddf6e3e0ef35eb7af254232ab70d8105f5b11af704770de81a15f7895499ee8a86a2479352627dac0b594
    BLAKE2c: 536245433930603620f007577d19b6d993b5dd75267e013c8965e73921db1f81
    BLAKE2b: 726bfdeb5fed358ce9827ca013e2dc0d7c34ba1d1900ddb5f46b5dd29d46c6e7bd87b610ea8e290765c3aac4d44ddea01d14e5073b8c743c67cd1da1ecdcef01
    
##
# [[] / []]()
Алгоритмы хэширования — это математические функции, которые преобразуют данные в хэш-значения фиксированной длины, хэш-коды или хэши. Выходное хэш-значение буквально представляет собой сводку исходного значения. Самое важное в этих хэш-значениях заключается в том, что невозможно извлечь исходные входные данные только из хэш-значений.

Теперь вы, возможно, думаете, в чем же польза от использования алгоритмов хеширования? Почему бы просто не использовать шифрование? Ну, несмотря на то, что шифрование важно для защиты данных (конфиденциальность данных), иногда важно иметь возможность доказать, что никто не изменил данные, которые вы отправляете. Используя значения хэширования, вы сможете определить, не был ли какой-либо файл изменен с момента создания (целостность данных).

Но это не так; существует множество примеров их использования, включая цифровые подписи, шифрование с открытым ключом, проверку подлинности сообщений, защиту паролем и многие другие криптографические протоколы. На самом деле, независимо от того, храните ли вы свои файлы в облачной системе хранения, используете систему контроля версий Git, подключаетесь к веб-сайту HTTPS, подключаетесь к удаленной машине с помощью SSH или даже отправляете сообщение на свой мобильный телефон, где-то под капотом есть функция хэша.

Читайте также: Как передавать файлы в сети с помощью сокетов в Python.

В этом уроке мы будем использовать встроенный модуль hashlib для использования различных хэш-алгоритмов в Python. Давайте начнем:

import hashlib

# encode it to bytes using UTF-8 encoding
message = "Some text to hash".encode()
Мы будем использовать различные хэш-алгоритмы для этой строки сообщения, начиная с MD5:

# hash with MD5 (not recommended)
print("MD5:", hashlib.md5(message).hexdigest())
Выпуск:

MD5: 3eecc85e6440899b28a9ea6d8369f01c
MD5 уже довольно устарел, и вы никогда не должны его использовать, так как он не устойчив к столкновениям. Давайте попробуем SHA-2:

# hash with SHA-2 (SHA-256 & SHA-512)
print("SHA-256:", hashlib.sha256(message).hexdigest())

print("SHA-512:", hashlib.sha512(message).hexdigest())
Выпуск:

SHA-256: 7a86e0e93e6aa6cf49f19368ca7242e24640a988ac8e5508dfcede39fa53faa2
SHA-512: 96fa772f72678c85bbd5d23b66d51d50f8f9824a0aba0ded624ab61fe8b602bf4e3611075fe13595d3e74c63c59f7d79241acc97888e9a7a5c791159c85c3ccd
Создайте 24 этических хакерских скрипта и инструмента с помощью Python Book

SHA-2 представляет собой семейство из 4 хэш-функций: SHA-224, SHA-256, SHA-384 и SHA-512, также можно использовать hashlib.sha224() и hashlib.sha-384(). Тем не менее, SHA-256 и SHA-512 в основном используются.

Причина, по которой он называется SHA-2 (Secure Hash Algorithm 2), заключается в том, что SHA-2 является преемником SHA-1, который устарел и легко ломается, мотивация SHA-2 заключалась в создании более длинных хэшей, что приводит к более высоким уровням безопасности, чем SHA-1.

Хотя SHA-2 все еще используется в настоящее время, многие считают, что атаки на SHA-2 являются лишь вопросом времени; Исследователи обеспокоены его долгосрочной безопасностью из-за его сходства с SHA-1.

В результате SHA-3 вводится NIST в качестве резервного плана, который представляет собой губчатую функцию, полностью отличающуюся от SHA-2 и SHA-1. Давайте посмотрим это в Python:

# hash with SHA-3
print("SHA-3-256:", hashlib.sha3_256(message).hexdigest())

print("SHA-3-512:", hashlib.sha3_512(message).hexdigest())
Выпуск:

SHA-3-256: d7007c1cd52f8168f22fa25ef011a5b3644bcb437efa46de34761d3340187609
SHA-3-512: de6b4c8f7d4fd608987c123122bcc63081372d09b4bc14955bfc828335dec1246b5c6633c5b1c87d2ad2b777d713d7777819263e7ad675a3743bf2a35bc699d0
SHA-3 вряд ли будет сломан в ближайшее время. Фактически, сотни опытных криптоаналитиков не смогли взломать SHA-3.

Что мы подразумеваем под безопасностью в алгоритмах хэширования? Функции хэширования имеют множество характеристик безопасности, в том числе устойчивость к коллизиям, которая обеспечивается алгоритмами, которые чрезвычайно затрудняют злоумышленнику поиск двух совершенно разных сообщений, которые хэшируют одно и то же хэш-значение.

Устойчивость к предварительному изображению также является ключевым фактором для безопасности хэш-алгоритма. Алгоритм, устойчивый к предварительному изображению, затрудняет и отнимает много времени у злоумышленника, чтобы найти исходное сообщение с учетом хэш-значения.

Существует мало стимулов для обновления до SHA-3, поскольку SHA-2 по-прежнему безопасен, и поскольку скорость также является проблемой, SHA-3 не быстрее, чем SHA-2.

Что, если мы хотим использовать более быструю хэш-функцию, более безопасную, чем SHA-2, и, по крайней мере, такую же безопасную, как SHA-3? Ответ лежит на BLAKE2:

# hash with BLAKE2
# 256-bit BLAKE2 (or BLAKE2s)
print("BLAKE2c:", hashlib.blake2s(message).hexdigest())
# 512-bit BLAKE2 (or BLAKE2b)
print("BLAKE2b:", hashlib.blake2b(message).hexdigest())
Связанные с: Создание 24 этических хакерских скриптов и инструментов с помощью Python.

Выпуск:

BLAKE2c: 6889074426b5454d751547cd33ca4c64cd693f86ce69be5c951223f3af845786
BLAKE2b: 13e2ca8f6a282f27b2022dde683490b1085b3e16a98ee77b44b25bc84a0366afe8d70a4aa47dd10e064f1f772573513d64d56e5ef646fb935c040b32f67e5ab2
Хэши BLAKE2 быстрее, чем SHA-1, SHA-2, SHA-3 и даже MD5, и даже более безопасны, чем SHA-2. Он подходит для использования на современных процессорах, поддерживающих параллельные вычисления на многоядерных системах.

BLAKE2 широко используется и был интегрирован в основные криптографические библиотеки, такие как OpenSSL и Sodium, и многое другое.

Вы также можете легко хэшировать весь файл, просто прочитав все содержимое файла, а затем передав байты файла любой функции, которую мы рассмотрели. Проверьте соответствующий код здесь.